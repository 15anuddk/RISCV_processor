$date
	Wed Oct 15 16:54:01 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ID_tb $end
$var wire 32 ! A_in [31:0] $end
$var wire 32 " write_data [31:0] $end
$var wire 32 # rs2_data [31:0] $end
$var wire 5 $ rs2 [4:0] $end
$var wire 32 % rs1_data [31:0] $end
$var wire 5 & rs1 [4:0] $end
$var wire 1 ' reg_write $end
$var wire 5 ( rd [4:0] $end
$var wire 7 ) opcode [6:0] $end
$var wire 1 * mem_write_n $end
$var wire 1 + mem_write $end
$var wire 1 , mem_to_reg_n $end
$var wire 1 - mem_to_reg $end
$var wire 1 . mem_read_n $end
$var wire 1 / mem_read $end
$var wire 1 0 jumpl_n $end
$var wire 1 1 jumpl $end
$var wire 7 2 funct7 [6:0] $end
$var wire 3 3 funct3 [2:0] $end
$var wire 1 4 branch_n $end
$var wire 1 5 branch $end
$var wire 1 6 alu_src $end
$var wire 4 7 alu_select [3:0] $end
$var wire 4 8 alu_sel [3:0] $end
$var wire 1 9 alu_op $end
$var wire 32 : PC_new [31:0] $end
$var wire 32 ; B_in [31:0] $end
$var wire 32 < B [31:0] $end
$var wire 32 = A [31:0] $end
$var reg 32 > PC_n [31:0] $end
$var reg 1 ? clk $end
$var reg 32 @ instr [31:0] $end
$var reg 1 A reset $end
$scope module a_c $end
$var wire 7 B func7 [6:0] $end
$var wire 3 C func3 [2:0] $end
$var wire 1 9 alu_op $end
$var reg 4 D sel [3:0] $end
$upscope $end
$scope module controller $end
$var wire 1 A reset $end
$var wire 7 E opcode [6:0] $end
$var reg 1 9 alu_op $end
$var reg 1 6 alu_src $end
$var reg 1 5 branch_en $end
$var reg 1 1 jumpl_en $end
$var reg 1 / mem_read_en $end
$var reg 1 - mem_to_reg_en $end
$var reg 1 + mem_write_en $end
$var reg 1 ' reg_write_en $end
$upscope $end
$scope module decode $end
$var wire 32 F instruction [31:0] $end
$var wire 5 G rs2 [4:0] $end
$var wire 5 H rs1 [4:0] $end
$var wire 5 I rd [4:0] $end
$var wire 7 J opcode [6:0] $end
$var wire 7 K func7 [6:0] $end
$var wire 3 L func3 [2:0] $end
$upscope $end
$scope module imm_values $end
$var wire 1 6 alu_src $end
$var wire 32 M instruction [31:0] $end
$var wire 1 + mem_write_en $end
$var wire 32 N rs2_data [31:0] $end
$var reg 32 O B [31:0] $end
$upscope $end
$scope module registers $end
$var wire 5 P rd [4:0] $end
$var wire 1 ' reg_write_en $end
$var wire 1 A reset $end
$var wire 5 Q rs1 [4:0] $end
$var wire 32 R rs1_data [31:0] $end
$var wire 5 S rs2 [4:0] $end
$var wire 32 T rs2_data [31:0] $end
$var wire 32 U write_data [31:0] $end
$var integer 32 V i [31:0] $end
$upscope $end
$scope module uut $end
$var wire 32 W A_in [31:0] $end
$var wire 32 X B_in [31:0] $end
$var wire 32 Y PC_n [31:0] $end
$var wire 1 5 branch $end
$var wire 1 ? clk $end
$var wire 1 1 jumpl_en $end
$var wire 1 / mem_read_en $end
$var wire 1 - mem_to_reg_en $end
$var wire 1 + mem_write_en $end
$var wire 1 A reset $end
$var wire 4 Z sel [3:0] $end
$var reg 32 [ A [31:0] $end
$var reg 32 \ B [31:0] $end
$var reg 32 ] PC_new [31:0] $end
$var reg 4 ^ alu_select [3:0] $end
$var reg 1 4 branch_n $end
$var reg 1 0 jumpl_n $end
$var reg 1 . mem_read_n $end
$var reg 1 , mem_to_reg_n $end
$var reg 1 * mem_write_n $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ^
bx ]
bx \
bx [
b0 Z
bx Y
b0 X
b0 W
b100000 V
bz U
b0 T
b0 S
b0 R
b10 Q
b1 P
b0 O
b0 N
b10010000010000011 M
b10 L
b0 K
b11 J
b1 I
b10 H
b0 G
b10010000010000011 F
b11 E
b0 D
b10 C
b0 B
1A
b10010000010000011 @
0?
bx >
bx =
bx <
b0 ;
bx :
09
b0 8
bx 7
16
05
x4
b10 3
b0 2
01
x0
1/
x.
1-
x,
0+
x*
b11 )
b1 (
1'
b10 &
b0 %
b0 $
b0 #
bz "
b0 !
$end
#10
b0 :
b0 ]
b0 7
b0 ^
b0 <
b0 \
b0 =
b0 [
04
00
0,
0*
0.
1?
#20
0?
0A
#30
bx :
bx ]
1,
1.
1?
#40
1+
b11 $
b11 G
b11 S
b100 &
b100 H
b100 Q
b0 (
b0 I
b0 P
b100011 )
b100011 E
b100011 J
b0 ;
b0 O
b0 X
0?
b1100100010000000100011 @
b1100100010000000100011 F
b1100100010000000100011 M
#50
1*
1?
#60
b1000 ;
b1000 O
b1000 X
0+
b1000 $
b1000 G
b1000 S
b110 &
b110 H
b110 Q
b101 (
b101 I
b101 P
b11 )
b11 E
b11 J
0?
b100000110010001010000011 @
b100000110010001010000011 F
b100000110010001010000011 M
#70
b1000 <
b1000 \
0*
1?
#80
b0 ;
b0 O
b0 X
06
0/
0-
11
b0 &
b0 H
b0 Q
b0 3
b0 C
b0 L
b1 (
b1 I
b1 P
b1101111 )
b1101111 E
b1101111 J
0?
b100000000000000011101111 @
b100000000000000011101111 F
b100000000000000011101111 M
#90
b0 <
b0 \
10
0,
0.
1?
#100
01
0'
15
b10 $
b10 G
b10 S
bz !
bz W
bz %
bz R
b1 &
b1 H
b1 Q
b1100 (
b1100 I
b1100 P
b1100011 )
b1100011 E
b1100011 J
0?
b1000001000011001100011 @
b1000001000011001100011 F
b1000001000011001100011 M
#110
bz =
bz [
14
00
1?
#120
bz ;
bz O
bz X
19
1'
bz #
bz N
bz T
b101 $
b101 G
b101 S
b0 !
b0 W
b0 %
b0 R
b100 &
b100 H
b100 Q
b11 (
b11 I
b11 P
b110011 )
b110011 E
b110011 J
0?
b10100100000000110110011 @
b10100100000000110110011 F
b10100100000000110110011 M
#130
bz <
bz \
b0 =
b0 [
1?
#140
b1010 ;
b1010 O
b1010 X
16
b0 #
b0 N
b0 T
b1010 $
b1010 G
b1010 S
b111 &
b111 H
b111 Q
b110 (
b110 I
b110 P
b10011 )
b10011 E
b10011 J
0?
b101000111000001100010011 @
b101000111000001100010011 F
b101000111000001100010011 M
#150
b1010 <
b1010 \
1?
#160
b0 ;
b0 O
b0 X
b10 8
b10 D
b10 Z
06
b1001 &
b1001 H
b1001 Q
b100 3
b100 C
b100 L
b1000 (
b1000 I
b1000 P
b110011 )
b110011 E
b110011 J
0?
b10010 >
b10010 Y
b101001001100010000110011 @
b101001001100010000110011 F
b101001001100010000110011 M
#170
b10010 :
b10010 ]
b10 7
b10 ^
b0 <
b0 \
1?
#180
0?
#190
1?
